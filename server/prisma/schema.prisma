generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Note: SQLite не поддерживает enum — используем String + валидацию на уровне API

model Tenant {
  id             String         @id @default(cuid())
  name           String
  positions      Position[]
  employees      Employee[]
  timesheets     Timesheet[]
  adjustments    Adjustment[]
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  payouts        Payout[]
  positionRates  PositionRate[]
  accounts       Account[]
  categories     Category[]
  articles       Article[]
  transactions   Transaction[]
  counterparties Counterparty[]
  statements     Statement[]
  users          User[]
  userRoles      UserRole[]
  auditLogs      AuditLog[]
  channels       Channel[]
  tenderTypes    TenderType[]
  shifts         Shift[]
  expenseDocs    ExpenseDoc[]
  payments       Payment[]
  cashTxs        CashTx[]
  telegramBindings TelegramBinding[]
  telegramBindRequests TelegramBindRequest[]
  magicLinkTokens MagicLinkToken[]
  productSuppliers ProductSupplier[]
  productBuffers ProductBuffer[]
  productStocks ProductStock[]
  orderSchedules OrderSchedule[]
  supplierOrders SupplierOrder[]
}

model Position {
  id                String         @id @default(cuid())
  tenantId          String
  tenant            Tenant         @relation(fields: [tenantId], references: [id])
  name              String
  baseHourRate      Int? // копейки, опционально
  kind              String // 'SHIFTS_PLUS_REVENUE' | 'SALARY' | 'SALARY_PLUS_TASKS'
  revenuePercentBps Int? // базисные пункты % выручки (0-10000)
  salaryAmount      Int? // оклад в копейках
  department        String? // 'KITCHEN' | 'HALL' | 'OFFICE'
  employees         Employee[]
  rates             PositionRate[]
}

model Employee {
  id               String        @id @default(cuid())
  tenantId         String
  tenant           Tenant        @relation(fields: [tenantId], references: [id])
  positionId       String?
  position         Position?     @relation(fields: [positionId], references: [id])
  fullName         String
  active           Boolean       @default(true)
  hiredAt          DateTime      @default(now())
  firedAt          DateTime?
  personalHourRate Int?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  timesheets       Timesheet[]
  adjustments      Adjustment[]
  payouts          Payout[]
  transactions     Transaction[]
}

model Timesheet {
  id         String   @id @default(cuid())
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id])
  employeeId String
  employee   Employee @relation(fields: [employeeId], references: [id])
  workDate   DateTime // date (00:00)
  minutes    Int // количество минут за день
  status     String   @default("draft") // 'draft' | 'approved'
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([employeeId, workDate])
}

model Adjustment {
  id         String   @id @default(cuid())
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id])
  employeeId String
  employee   Employee @relation(fields: [employeeId], references: [id])
  date       DateTime
  kind       String // 'bonus' | 'fine' | 'deduction'
  amount     Int // копейки, положительное
  reason     String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model Account {
  id           String        @id @default(cuid())
  tenantId     String
  tenant       Tenant        @relation(fields: [tenantId], references: [id])
  name         String
  kind         String // 'cash' | 'bank' | 'card' | 'safe'
  active       Boolean       @default(true)
  payouts      Payout[]
  transactions Transaction[] @relation("AccountTransactions")
  statements   Statement[]
  payments     Payment[]
  cashTxs      CashTx[]
  createdBy    String?
  updatedBy    String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
}

model Payout {
  id         String   @id @default(cuid())
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id])
  employeeId String
  employee   Employee @relation(fields: [employeeId], references: [id])
  date       DateTime
  // период начисления, за который платим
  year       Int
  month      Int
  amount     Int // копейки, положительное
  method     String // 'cash' | 'card'
  accountId  String?
  account    Account? @relation(fields: [accountId], references: [id])
  note       String?
  createdBy  String?
  updatedBy  String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

model PositionRate {
  id                String   @id @default(cuid())
  tenantId          String
  tenant            Tenant   @relation(fields: [tenantId], references: [id])
  positionId        String
  position          Position @relation(fields: [positionId], references: [id])
  year              Int
  month             Int
  baseHourRate      Int?
  revenuePercentBps Int?
  salaryAmount      Int?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([positionId, year, month])
}

model Category {
  id           String        @id @default(cuid())
  tenantId     String
  tenant       Tenant        @relation(fields: [tenantId], references: [id])
  name         String
  type         String // 'expense' | 'income'
  kind         String? // 'COGS' | 'OPEX' | 'CAPEX' | 'TAX' | 'FEE' | 'OTHER'
  activity     String // 'OPERATING' | 'INVESTING' | 'FINANCING'
  parentId     String?
  parent       Category?     @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children     Category[]    @relation("CategoryHierarchy")
  fund         String?
  active       Boolean       @default(true)
  createdBy    String?
  updatedBy    String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  transactions Transaction[]
  expenseDocs  ExpenseDoc[]
  articles     Article[]
}

// Новая сущность: статьи как дети корневых категорий
model Article {
  id         String   @id @default(cuid())
  tenantId   String
  tenant     Tenant   @relation(fields: [tenantId], references: [id])
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])
  name       String
  fund       String?
  active     Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([categoryId, name])
  @@index([fund])
}

model Statement {
  id          String          @id @default(cuid())
  tenantId    String
  tenant      Tenant          @relation(fields: [tenantId], references: [id])
  accountId   String
  account     Account         @relation(fields: [accountId], references: [id])
  periodYear  Int
  periodMonth Int
  opening     Int
  closing     Int
  source      String?
  createdBy   String?
  updatedBy   String?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  lines       StatementLine[]

  @@unique([accountId, periodYear, periodMonth])
}

model StatementLine {
  id                   String    @id @default(cuid())
  statementId          String
  statement            Statement @relation(fields: [statementId], references: [id])
  paymentDate          DateTime
  amount               Int
  description          String?
  externalId           String?
  matchedTransactionId String?
  status               String?
  createdBy            String?
  createdAt            DateTime  @default(now())
}

// ===== RBAC & Users =====

model User {
  id        String     @id @default(cuid())
  tenantId  String
  tenant    Tenant     @relation(fields: [tenantId], references: [id])
  fullName  String
  phone     String     @unique
  active    Boolean    @default(true)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  roles     UserRole[]
  auditLogs AuditLog[]
  telegramBindings TelegramBinding[]
  telegramBindRequests TelegramBindRequest[]
  magicLinkTokens MagicLinkToken[]
}

model Role {
  id        String           @id @default(cuid())
  name      String           @unique
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  users     UserRole[]
  rolePerms RolePermission[]
}

model Permission {
  id          String           @id @default(cuid())
  name        String           @unique
  description String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  rolePerms   RolePermission[]
}

model UserRole {
  id        String   @id @default(cuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  roleId    String
  role      Role     @relation(fields: [roleId], references: [id])
  createdAt DateTime @default(now())

  @@unique([tenantId, userId, roleId])
}

model RolePermission {
  id           String     @id @default(cuid())
  roleId       String
  role         Role       @relation(fields: [roleId], references: [id])
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id])
  createdAt    DateTime   @default(now())

  @@unique([roleId, permissionId])
}

model AuditLog {
  id        String   @id @default(cuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  action    String
  entity    String
  entityId  String?
  diff      String? // JSON
  ip        String?
  ua        String?
  createdAt DateTime @default(now())

  @@index([tenantId, entity])
}

// ===== Telegram Binding & Magic Links =====

model TelegramBinding {
  id        String   @id @default(cuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  chatId    String   // telegram chat_id (в личке == user id)
  createdAt DateTime @default(now())

  @@unique([tenantId, userId])
  @@unique([tenantId, chatId])
}

model TelegramBindRequest {
  id        String   @id @default(cuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  code      String   @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())

  @@index([tenantId, userId])
}

model MagicLinkToken {
  id        String   @id @default(cuid()) // jti
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  redirect  String?
  expiresAt DateTime
  usedAt    DateTime?
  usedIp    String?
  usedUa    String?
  createdAt DateTime @default(now())

  @@index([tenantId, userId])
  @@index([expiresAt])
}

model Counterparty {
  id           String        @id @default(cuid())
  tenantId     String
  tenant       Tenant        @relation(fields: [tenantId], references: [id])
  name         String
  kind         String?
  active       Boolean       @default(true)
  transactions Transaction[]
  expenseDocs  ExpenseDoc[]
  productSuppliers ProductSupplier[]
  orderSchedules OrderSchedule[]
  supplierOrders SupplierOrder[]
  createdBy    String?
  updatedBy    String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
}

model Transaction {
  id             String        @id @default(cuid())
  tenantId       String
  tenant         Tenant        @relation(fields: [tenantId], references: [id])
  kind           String // 'expense' | 'income' | 'transfer' | 'adjustment'
  paymentDate    DateTime
  accrualYear    Int?
  accrualMonth   Int?
  accountId      String?
  account        Account?      @relation("AccountTransactions", fields: [accountId], references: [id])
  fromAccountId  String?
  toAccountId    String?
  categoryId     String?
  category       Category?     @relation(fields: [categoryId], references: [id])
  employeeId     String?
  employee       Employee?     @relation(fields: [employeeId], references: [id])
  counterpartyId String?
  counterparty   Counterparty? @relation(fields: [counterpartyId], references: [id])
  method         String?
  amount         Int
  note           String?
  source         String?
  activity       String? // 'operating' | 'investing' | 'financing'
  createdBy      String?
  updatedBy      String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@index([paymentDate])
  @@index([accrualYear, accrualMonth])
  @@index([kind])
  @@index([accountId])
  @@index([categoryId])
}

// ===== Cafe Finance Lite v3 Models =====

// Справочник каналов продаж
model Channel {
  id         String      @id @default(cuid())
  tenantId   String
  tenant     Tenant      @relation(fields: [tenantId], references: [id])
  name       String // 'Dine-in', 'Pickup', 'Grab', 'Foodpanda'
  active     Boolean     @default(true)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  shiftSales ShiftSale[]
}

// Справочник способов оплаты
model TenderType {
  id         String      @id @default(cuid())
  tenantId   String
  tenant     Tenant      @relation(fields: [tenantId], references: [id])
  name       String // 'cash', 'card', 'qr', 'aggregator'
  active     Boolean     @default(true)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  shiftSales ShiftSale[]
}

// Смены
model Shift {
  id             String      @id @default(cuid())
  tenantId       String
  tenant         Tenant      @relation(fields: [tenantId], references: [id])
  openAt         DateTime
  closeAt        DateTime?
  openedBy       String?
  closedBy       String?
  note           String?
  iikoSessionNum Int? // номер смены из iiko API
  iikoCashRegNum Int? // номер кассы из iiko API
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
  sales          ShiftSale[]

  @@index([openAt])
  @@index([closeAt])
  @@index([iikoSessionNum])
}

// Продажи по сменам (канал × способ оплаты)
model ShiftSale {
  id           String     @id @default(cuid())
  shiftId      String
  shift        Shift      @relation(fields: [shiftId], references: [id])
  channelId    String
  channel      Channel    @relation(fields: [channelId], references: [id])
  tenderTypeId String
  tenderType   TenderType @relation(fields: [tenderTypeId], references: [id])
  grossAmount  Int // в копейках
  discounts    Int        @default(0)
  refunds      Int        @default(0)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@index([shiftId])
}

// Документы расходов (с учётом долгов)
model ExpenseDoc {
  id            String              @id @default(cuid())
  tenantId      String
  tenant        Tenant              @relation(fields: [tenantId], references: [id])
  vendorId      String?
  vendor        Counterparty?       @relation(fields: [vendorId], references: [id])
  categoryId    String
  category      Category            @relation(fields: [categoryId], references: [id])
  operationDate DateTime // дата счёта/акта
  postingPeriod DateTime // 1-е число месяца учёта
  amount        Int // сумма документа (копейки)
  paidAmount    Int                 @default(0) // суммарно оплачено
  status        String // 'draft'|'unpaid'|'partial'|'paid'|'void'
  activity      String // 'operating'|'investing'|'financing'
  memo          String?
  createdBy     String?
  updatedBy     String?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  payments      Payment[]
  allocations   PaymentAllocation[]

  @@index([postingPeriod])
  @@index([status])
  @@index([vendorId])
}

// Платежи
model Payment {
  id           String              @id @default(cuid())
  tenantId     String
  tenant       Tenant              @relation(fields: [tenantId], references: [id])
  expenseDocId String? // если null - разовый платёж
  expenseDoc   ExpenseDoc?         @relation(fields: [expenseDocId], references: [id])
  accountId    String
  account      Account             @relation(fields: [accountId], references: [id])
  date         DateTime
  amount       Int // копейки
  activity     String? // для переопределения вида деятельности
  memo         String?
  createdBy    String?
  updatedBy    String?
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  allocations  PaymentAllocation[]
  cashTxs      CashTx[]

  @@index([date])
  @@index([expenseDocId])
}

// Распределение платежей на документы
model PaymentAllocation {
  id           String     @id @default(cuid())
  paymentId    String
  payment      Payment    @relation(fields: [paymentId], references: [id])
  expenseDocId String
  expenseDoc   ExpenseDoc @relation(fields: [expenseDocId], references: [id])
  amount       Int // копейки
  createdAt    DateTime   @default(now())

  @@index([paymentId])
  @@index([expenseDocId])
}

// Денежные операции (реальные движения денег)
model CashTx {
  id                     String   @id @default(cuid())
  tenantId               String
  tenant                 Tenant   @relation(fields: [tenantId], references: [id])
  accountId              String
  account                Account  @relation(fields: [accountId], references: [id])
  date                   DateTime
  direction              String // 'in'|'out'
  amount                 Int // копейки
  sourceType             String // 'shift'|'payment'|'bank_fee'|'transfer'
  sourceId               String
  memo                   String?
  activity               String // 'operating'|'investing'|'financing'
  matchedStatementLineId String?
  paymentId              String? // связь с Payment если источник - платёж
  payment                Payment? @relation(fields: [paymentId], references: [id])
  createdAt              DateTime @default(now())

  @@index([date])
  @@index([activity])
  @@index([direction])
  @@index([accountId])
}

// ===== iiko Receipts staging (для локального хранения чеков) =====

model IikoReceipt {
  id                  String            @id @default(cuid())
  orderNum            String
  date                DateTime
  waiter              String?
  register            String?
  sessionNumber       Int? // номер кассовой смены из iiko
  cashRegNumber       Int? // номер кассы (ФРа) из iiko
  customerName        String?
  customerPhone       String?
  orderType           String?
  deliveryServiceType String?
  isReturn            Boolean?
  returnSum           Int? // сумма возврата по чеку (целая)
  isDeleted           Boolean? // флаг удаленного чека
  deletedWithWriteoff Boolean? // удален с/без списания
  orderDeleted        String? // статус удаления чека (DELETED/NOT_DELETED)
  openTime            DateTime? // время открытия чека
  closeTime           DateTime? // время закрытия чека
  rawJson             String? // полный OLAP-ряд по чеку
  payTypesJson        String? // JSON-массив типов оплат
  guests              Int?
  net                 Int? // сумма по чеку (целое)
  cost                Int? // себестоимость (целое)
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  items               IikoReceiptItem[]

  @@unique([orderNum, date])
  @@index([date])
  @@index([isDeleted])
  @@index([isReturn])
  @@index([date, isDeleted, isReturn])
  @@index([orderNum, date])
  @@index([sessionNumber])
  @@index([cashRegNumber])
}

model IikoReceiptItem {
  receiptId    String
  lineNo       Int
  dishId       String?
  dishName     String?
  dishCategory String? // категория блюда из iiko (DishCategory)
  size         String?
  qty          Int?
  net          Int?
  cost         Int?
  measureUnit  String?
  returnSum    Int?
  rawJson      String? // полный OLAP-ряд по позиции

  receipt IikoReceipt @relation(fields: [receiptId], references: [id])

  @@id([receiptId, lineNo])
  @@index([dishCategory]) // для быстрой фильтрации по категориям
  @@index([dishId])
  @@index([dishCategory, dishId])
}

// Нормализованное хранилище всех колонок OLAP SALES (чек/позиция) в формате ключ-значение
model IikoOlapRowKV {
  id        String   @id @default(cuid())
  date      DateTime
  orderNum  String
  level     String // 'RECEIPT' | 'ITEM'
  itemKey   String? // идентификатор позиции (например, DishId)
  col       String // имя колонки из OLAP (как в API)
  valStr    String?
  valNum    Float?
  createdAt DateTime @default(now())

  @@index([date, orderNum])
  @@index([col])
}

model IikoImportCheckpoint {
  jobName   String   @id
  cursor    String?
  updatedAt DateTime @updatedAt
}

// ===== GSheets staging for cashflow =====
model GsCashflowRow {
  id          String    @id @default(cuid())
  spreadsheet String
  sheet       String
  rowNum      Int
  monthName   String?
  monthNum    Int?
  date        DateTime?
  dateText    String?
  amount      Int? // в копейках
  wallet      String?
  supplier    String?
  comment     String?
  fund        String?
  flowType    String? // Поступление | Выбытие
  activity    String? // Операционная и т.п.
  raw         String? // JSON исходной строки
  createdAt   DateTime  @default(now())

  @@unique([spreadsheet, sheet, rowNum])
  @@index([spreadsheet, sheet])
}

// ===== Система закупа =====

// Поставщики продуктов (связь продукт-поставщик)
model ProductSupplier {
  id             String    @id @default(cuid())
  tenantId       String
  tenant         Tenant    @relation(fields: [tenantId], references: [id])
  productId      String    // ID продукта из iiko (dishId)
  productName    String    // Название продукта для отображения
  supplierId     String    // ID поставщика (Counterparty)
  supplier       Counterparty @relation(fields: [supplierId], references: [id])
  isPrimary      Boolean   @default(false) // Основной поставщик
  priority       Int       @default(1) // Приоритет среди запасных (1, 2, 3...)
  isActive       Boolean   @default(true)
  minOrderAmount Int?      // Минимальная сумма заказа в копейках
  deliveryDays   Int       @default(1) // Дни доставки (1-7)
  price          Int?      // Цена за единицу в копейках (если фиксированная)
  unit           String    @default("кг") // Единица измерения
  notes          String?
  createdBy      String?
  updatedBy      String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@unique([productId, supplierId])
  @@index([productId])
  @@index([supplierId])
  @@index([isPrimary, priority])
}

// Буферные запасы продуктов
model ProductBuffer {
  id          String   @id @default(cuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id])
  productId   String   // ID продукта из iiko (dishId)
  productName String   // Название продукта для отображения
  bufferDays  Int      @default(7) // На сколько дней буфер
  minBuffer   Float    @default(0) // Минимальный буфер в единицах
  maxBuffer   Float?   // Максимальный буфер в единицах
  isActive    Boolean  @default(true)
  notes       String?
  createdBy   String?
  updatedBy   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([productId])
  @@index([productId])
}

// Остатки продуктов на складах
model ProductStock {
  id                String   @id @default(cuid())
  tenantId          String
  tenant            Tenant   @relation(fields: [tenantId], references: [id])
  productId         String   // ID продукта из iiko (dishId)
  productName       String   // Название продукта для отображения
  storeId           String   // ID склада из iiko
  storeName         String   // Название склада
  currentStock      Float    @default(0) // Текущий остаток
  reservedStock     Float    @default(0) // Зарезервировано
  lastUpdated       DateTime @default(now())
  lastSyncWithIiko  DateTime @default(now())
  notes             String?
  createdBy         String?
  updatedBy         String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([productId, storeId])
  @@index([productId])
  @@index([storeId])
}

// График заказов
model OrderSchedule {
  id          String   @id @default(cuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id])
  supplierId  String   // ID поставщика (Counterparty)
  supplier    Counterparty @relation(fields: [supplierId], references: [id])
  dayOfWeek   Int      // День недели (1-7, где 1 = понедельник)
  orderTime   String   // Время заказа (HH:MM)
  isActive    Boolean  @default(true)
  autoCreate  Boolean  @default(false) // Автоматически создавать заказы
  notes       String?
  createdBy   String?
  updatedBy   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([supplierId, dayOfWeek])
  @@index([supplierId])
  @@index([dayOfWeek])
}

// Заказы поставщикам
model SupplierOrder {
  id            String              @id @default(cuid())
  tenantId      String
  tenant        Tenant              @relation(fields: [tenantId], references: [id])
  supplierId    String              // ID поставщика (Counterparty)
  supplier      Counterparty        @relation(fields: [supplierId], references: [id])
  status        String              @default("DRAFT") // DRAFT | SENT | CONFIRMED | DELIVERED | CANCELLED
  orderDate     DateTime            @default(now()) // Дата создания заказа
  scheduledDate DateTime            // Планируемая дата заказа
  deliveryDate  DateTime?           // Дата доставки
  totalAmount   Int                 @default(0) // Общая сумма заказа в копейках
  items         SupplierOrderItem[]
  notes         String?
  createdBy     String?
  updatedBy     String?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  @@index([supplierId])
  @@index([status])
  @@index([orderDate])
  @@index([scheduledDate])
}

// Позиции заказа
model SupplierOrderItem {
  id            String        @id @default(cuid())
  orderId       String
  order         SupplierOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId     String        // ID продукта из iiko (dishId)
  productName   String        // Название продукта для отображения
  quantity      Float         // Количество к заказу
  unit          String        // Единица измерения
  price         Int?          // Цена за единицу в копейках
  totalAmount   Int           @default(0) // Сумма позиции в копейках
  notes         String?
  createdBy     String?
  updatedBy     String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@index([orderId])
  @@index([productId])
}
